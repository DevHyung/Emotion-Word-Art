{"ast":null,"code":"import _classCallCheck from \"/Users/yoonmee/Downloads/KHUVELOPER-frontend-master/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/yoonmee/Downloads/KHUVELOPER-frontend-master/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/yoonmee/Downloads/KHUVELOPER-frontend-master/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/yoonmee/Downloads/KHUVELOPER-frontend-master/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/yoonmee/Downloads/KHUVELOPER-frontend-master/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/yoonmee/Downloads/KHUVELOPER-frontend-master/src/Typing.js\";\nimport React, { Component, Fragment } from \"react\";\nimport { connect } from \"react-redux\";\nimport { bindActionCreators } from \"redux\";\nimport * as reducer from \"./store\";\nimport Typist from \"react-typist\";\n\nvar Typing =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Typing, _Component);\n\n  function Typing() {\n    var _this;\n\n    _classCallCheck(this, Typing);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Typing).call(this));\n\n    _this.getWord = function (newSentence) {\n      // 출력할 문장 설정\n      // (새 문장일 경우: newSentence, 기존 문장일 경우: state의 sentence)\n      var sentence = newSentence;\n      if (!sentence) sentence = _this.state.sentence;\n      var typingIng = _this.props.typingIng;\n\n      _this.setState({\n        word: sentence[0],\n        sentence: sentence.slice(1)\n      });\n\n      return typingIng(sentence[0]);\n    };\n\n    _this.state = {\n      word: \"\",\n      sentence: \"\"\n    };\n    return _this;\n  }\n\n  _createClass(Typing, [{\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      // 최초 실행 시 buffer에서 가져올 문장 설정하기\n      var _this$props = this.props,\n          setNextSentence = _this$props.setNextSentence,\n          buffer = _this$props.buffer;\n      if (buffer.length !== 0) return setNextSentence();\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var typingStatus = nextProps.typingStatus,\n          newSentence = nextProps.newSentence,\n          buffer = nextProps.buffer; // 가져올 새 문장이 있을 때\n\n      if (newSentence) {\n        var fetchSentence = this.props.fetchSentence;\n        fetchSentence();\n        return this.getWord(nextProps.sentence); // return this.setNewSentence(sentence);\n      } // typingStatus가 none일 때, 다음 글자 받아오기\n\n\n      var sentence = this.state.sentence;\n\n      if (typingStatus === \"none\") {\n        // 출력할 문장이 남아있는 경우 다음 단어를 가져옴\n        if (sentence) return this.getWord();\n        var setNextSentence = this.props.setNextSentence; // 버퍼가 비지 않았을 때, 다음 문장을 가져옴\n\n        if (buffer.length !== 0) return setNextSentence();\n      }\n    } // 다음 단어를 가져오는 함수\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var word = this.state.word;\n      var _this$props2 = this.props,\n          typingStatus = _this$props2.typingStatus,\n          typingDone = _this$props2.typingDone;\n      var cursor = {\n        show: false\n      };\n      if (typingStatus !== \"typing\") return React.createElement(\"div\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 68\n        },\n        __self: this\n      });\n      return React.createElement(Fragment, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 70\n        },\n        __self: this\n      }, React.createElement(Typist, {\n        onTypingDone: typingDone,\n        cursor: cursor,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 71\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        className: \"word\",\n        style: {\n          color: \"black\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 72\n        },\n        __self: this\n      }, word)));\n    }\n  }]);\n\n  return Typing;\n}(Component);\n\nexport default connect(function (state) {\n  return {\n    typingStatus: state.typingStatus,\n    word: state.word,\n    sentence: state.sentence,\n    newSentence: state.newSentence,\n    buffer: state.buffer\n  };\n}, function (dispatch) {\n  return {\n    typingDone: bindActionCreators(reducer.typingDone, dispatch),\n    typingIng: bindActionCreators(reducer.typingIng, dispatch),\n    setNextSentence: bindActionCreators(reducer.setNextSentence, dispatch),\n    fetchSentence: bindActionCreators(reducer.fetchSentence, dispatch)\n  };\n})(Typing);","map":{"version":3,"sources":["/Users/yoonmee/Downloads/KHUVELOPER-frontend-master/src/Typing.js"],"names":["React","Component","Fragment","connect","bindActionCreators","reducer","Typist","Typing","getWord","newSentence","sentence","state","typingIng","props","setState","word","slice","setNextSentence","buffer","length","nextProps","typingStatus","fetchSentence","typingDone","cursor","show","color","dispatch"],"mappings":"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","sourcesContent":["import React, { Component, Fragment } from \"react\";\n\nimport { connect } from \"react-redux\";\nimport { bindActionCreators } from \"redux\";\nimport * as reducer from \"./store\";\n\nimport Typist from \"react-typist\";\n\nclass Typing extends Component {\n  constructor() {\n    super();\n    this.state = {\n      word: \"\",\n      sentence: \"\"\n    };\n  }\n\n  componentWillMount() {\n    // 최초 실행 시 buffer에서 가져올 문장 설정하기\n    const { setNextSentence, buffer } = this.props;\n    if (buffer.length !== 0) return setNextSentence();\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const { typingStatus, newSentence, buffer } = nextProps;\n\n    // 가져올 새 문장이 있을 때\n    if (newSentence) {\n      const { fetchSentence } = this.props;\n      fetchSentence();\n      return this.getWord(nextProps.sentence);\n      // return this.setNewSentence(sentence);\n    }\n\n    // typingStatus가 none일 때, 다음 글자 받아오기\n    const { sentence } = this.state;\n    if (typingStatus === \"none\") {\n      // 출력할 문장이 남아있는 경우 다음 단어를 가져옴\n      if (sentence) return this.getWord();\n\n      const { setNextSentence } = this.props;\n      // 버퍼가 비지 않았을 때, 다음 문장을 가져옴\n      if (buffer.length !== 0) return setNextSentence();\n    }\n  }\n\n  // 다음 단어를 가져오는 함수\n  getWord = newSentence => {\n    // 출력할 문장 설정\n    // (새 문장일 경우: newSentence, 기존 문장일 경우: state의 sentence)\n    let sentence = newSentence;\n    if (!sentence) sentence = this.state.sentence;\n\n    const { typingIng } = this.props;\n    this.setState({\n      word: sentence[0],\n      sentence: sentence.slice(1)\n    });\n\n    return typingIng(sentence[0]);\n  };\n\n  render() {\n    const { word } = this.state;\n    const { typingStatus, typingDone } = this.props;\n    const cursor = { show: false };\n\n    if (typingStatus !== \"typing\") return <div />;\n    return (\n      <Fragment>\n        <Typist onTypingDone={typingDone} cursor={cursor}>\n          <div className=\"word\" style={{ color: \"black\" }}>\n            {word}\n          </div>\n        </Typist>\n      </Fragment>\n    );\n  }\n}\n\nexport default connect(\n  state => ({\n    typingStatus: state.typingStatus,\n    word: state.word,\n    sentence: state.sentence,\n    newSentence: state.newSentence,\n    buffer: state.buffer\n  }),\n  dispatch => ({\n    typingDone: bindActionCreators(reducer.typingDone, dispatch),\n    typingIng: bindActionCreators(reducer.typingIng, dispatch),\n    setNextSentence: bindActionCreators(reducer.setNextSentence, dispatch),\n    fetchSentence: bindActionCreators(reducer.fetchSentence, dispatch)\n  })\n)(Typing);\n"]},"metadata":{},"sourceType":"module"}